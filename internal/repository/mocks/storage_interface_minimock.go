// Code generated by http://github.com/gojuno/minimock (v3.4.1). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/Dnlbb/auth/internal/repository/repoInterface.StorageInterface -o storage_interface_minimock.go -n StorageInterfaceMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/Dnlbb/auth/internal/models"
	"github.com/gojuno/minimock/v3"
)

// StorageInterfaceMock implements mm_repoInterface.StorageInterface
type StorageInterfaceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcDelete          func(ctx context.Context, id models.DeleteID) (err error)
	funcDeleteOrigin    string
	inspectFuncDelete   func(ctx context.Context, id models.DeleteID)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mStorageInterfaceMockDelete

	funcGetUser          func(ctx context.Context, params models.GetUserParams) (up1 *models.User, err error)
	funcGetUserOrigin    string
	inspectFuncGetUser   func(ctx context.Context, params models.GetUserParams)
	afterGetUserCounter  uint64
	beforeGetUserCounter uint64
	GetUserMock          mStorageInterfaceMockGetUser

	funcLog          func(ctx context.Context, key models.LogKey) (err error)
	funcLogOrigin    string
	inspectFuncLog   func(ctx context.Context, key models.LogKey)
	afterLogCounter  uint64
	beforeLogCounter uint64
	LogMock          mStorageInterfaceMockLog

	funcSave          func(ctx context.Context, user models.User) (i1 int64, err error)
	funcSaveOrigin    string
	inspectFuncSave   func(ctx context.Context, user models.User)
	afterSaveCounter  uint64
	beforeSaveCounter uint64
	SaveMock          mStorageInterfaceMockSave

	funcUpdate          func(ctx context.Context, update models.User) (err error)
	funcUpdateOrigin    string
	inspectFuncUpdate   func(ctx context.Context, update models.User)
	afterUpdateCounter  uint64
	beforeUpdateCounter uint64
	UpdateMock          mStorageInterfaceMockUpdate
}

// NewStorageInterfaceMock returns a mock for mm_repoInterface.StorageInterface
func NewStorageInterfaceMock(t minimock.Tester) *StorageInterfaceMock {
	m := &StorageInterfaceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.DeleteMock = mStorageInterfaceMockDelete{mock: m}
	m.DeleteMock.callArgs = []*StorageInterfaceMockDeleteParams{}

	m.GetUserMock = mStorageInterfaceMockGetUser{mock: m}
	m.GetUserMock.callArgs = []*StorageInterfaceMockGetUserParams{}

	m.LogMock = mStorageInterfaceMockLog{mock: m}
	m.LogMock.callArgs = []*StorageInterfaceMockLogParams{}

	m.SaveMock = mStorageInterfaceMockSave{mock: m}
	m.SaveMock.callArgs = []*StorageInterfaceMockSaveParams{}

	m.UpdateMock = mStorageInterfaceMockUpdate{mock: m}
	m.UpdateMock.callArgs = []*StorageInterfaceMockUpdateParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mStorageInterfaceMockDelete struct {
	optional           bool
	mock               *StorageInterfaceMock
	defaultExpectation *StorageInterfaceMockDeleteExpectation
	expectations       []*StorageInterfaceMockDeleteExpectation

	callArgs []*StorageInterfaceMockDeleteParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageInterfaceMockDeleteExpectation specifies expectation struct of the StorageInterface.Delete
type StorageInterfaceMockDeleteExpectation struct {
	mock               *StorageInterfaceMock
	params             *StorageInterfaceMockDeleteParams
	paramPtrs          *StorageInterfaceMockDeleteParamPtrs
	expectationOrigins StorageInterfaceMockDeleteExpectationOrigins
	results            *StorageInterfaceMockDeleteResults
	returnOrigin       string
	Counter            uint64
}

// StorageInterfaceMockDeleteParams contains parameters of the StorageInterface.Delete
type StorageInterfaceMockDeleteParams struct {
	ctx context.Context
	id  models.DeleteID
}

// StorageInterfaceMockDeleteParamPtrs contains pointers to parameters of the StorageInterface.Delete
type StorageInterfaceMockDeleteParamPtrs struct {
	ctx *context.Context
	id  *models.DeleteID
}

// StorageInterfaceMockDeleteResults contains results of the StorageInterface.Delete
type StorageInterfaceMockDeleteResults struct {
	err error
}

// StorageInterfaceMockDeleteOrigins contains origins of expectations of the StorageInterface.Delete
type StorageInterfaceMockDeleteExpectationOrigins struct {
	origin    string
	originCtx string
	originId  string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDelete *mStorageInterfaceMockDelete) Optional() *mStorageInterfaceMockDelete {
	mmDelete.optional = true
	return mmDelete
}

// Expect sets up expected params for StorageInterface.Delete
func (mmDelete *mStorageInterfaceMockDelete) Expect(ctx context.Context, id models.DeleteID) *mStorageInterfaceMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("StorageInterfaceMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &StorageInterfaceMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.paramPtrs != nil {
		mmDelete.mock.t.Fatalf("StorageInterfaceMock.Delete mock is already set by ExpectParams functions")
	}

	mmDelete.defaultExpectation.params = &StorageInterfaceMockDeleteParams{ctx, id}
	mmDelete.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// ExpectCtxParam1 sets up expected param ctx for StorageInterface.Delete
func (mmDelete *mStorageInterfaceMockDelete) ExpectCtxParam1(ctx context.Context) *mStorageInterfaceMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("StorageInterfaceMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &StorageInterfaceMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("StorageInterfaceMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &StorageInterfaceMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.ctx = &ctx
	mmDelete.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDelete
}

// ExpectIdParam2 sets up expected param id for StorageInterface.Delete
func (mmDelete *mStorageInterfaceMockDelete) ExpectIdParam2(id models.DeleteID) *mStorageInterfaceMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("StorageInterfaceMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &StorageInterfaceMockDeleteExpectation{}
	}

	if mmDelete.defaultExpectation.params != nil {
		mmDelete.mock.t.Fatalf("StorageInterfaceMock.Delete mock is already set by Expect")
	}

	if mmDelete.defaultExpectation.paramPtrs == nil {
		mmDelete.defaultExpectation.paramPtrs = &StorageInterfaceMockDeleteParamPtrs{}
	}
	mmDelete.defaultExpectation.paramPtrs.id = &id
	mmDelete.defaultExpectation.expectationOrigins.originId = minimock.CallerInfo(1)

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the StorageInterface.Delete
func (mmDelete *mStorageInterfaceMockDelete) Inspect(f func(ctx context.Context, id models.DeleteID)) *mStorageInterfaceMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for StorageInterfaceMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by StorageInterface.Delete
func (mmDelete *mStorageInterfaceMockDelete) Return(err error) *StorageInterfaceMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("StorageInterfaceMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &StorageInterfaceMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &StorageInterfaceMockDeleteResults{err}
	mmDelete.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDelete.mock
}

// Set uses given function f to mock the StorageInterface.Delete method
func (mmDelete *mStorageInterfaceMockDelete) Set(f func(ctx context.Context, id models.DeleteID) (err error)) *StorageInterfaceMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the StorageInterface.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the StorageInterface.Delete method")
	}

	mmDelete.mock.funcDelete = f
	mmDelete.mock.funcDeleteOrigin = minimock.CallerInfo(1)
	return mmDelete.mock
}

// When sets expectation for the StorageInterface.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mStorageInterfaceMockDelete) When(ctx context.Context, id models.DeleteID) *StorageInterfaceMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("StorageInterfaceMock.Delete mock is already set by Set")
	}

	expectation := &StorageInterfaceMockDeleteExpectation{
		mock:               mmDelete.mock,
		params:             &StorageInterfaceMockDeleteParams{ctx, id},
		expectationOrigins: StorageInterfaceMockDeleteExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up StorageInterface.Delete return parameters for the expectation previously defined by the When method
func (e *StorageInterfaceMockDeleteExpectation) Then(err error) *StorageInterfaceMock {
	e.results = &StorageInterfaceMockDeleteResults{err}
	return e.mock
}

// Times sets number of times StorageInterface.Delete should be invoked
func (mmDelete *mStorageInterfaceMockDelete) Times(n uint64) *mStorageInterfaceMockDelete {
	if n == 0 {
		mmDelete.mock.t.Fatalf("Times of StorageInterfaceMock.Delete mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDelete.expectedInvocations, n)
	mmDelete.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDelete
}

func (mmDelete *mStorageInterfaceMockDelete) invocationsDone() bool {
	if len(mmDelete.expectations) == 0 && mmDelete.defaultExpectation == nil && mmDelete.mock.funcDelete == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDelete.mock.afterDeleteCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDelete.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Delete implements mm_repoInterface.StorageInterface
func (mmDelete *StorageInterfaceMock) Delete(ctx context.Context, id models.DeleteID) (err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	mmDelete.t.Helper()

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(ctx, id)
	}

	mm_params := StorageInterfaceMockDeleteParams{ctx, id}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, &mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_want_ptrs := mmDelete.DeleteMock.defaultExpectation.paramPtrs

		mm_got := StorageInterfaceMockDeleteParams{ctx, id}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDelete.t.Errorf("StorageInterfaceMock.Delete got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.id != nil && !minimock.Equal(*mm_want_ptrs.id, mm_got.id) {
				mmDelete.t.Errorf("StorageInterfaceMock.Delete got unexpected parameter id, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDelete.DeleteMock.defaultExpectation.expectationOrigins.originId, *mm_want_ptrs.id, mm_got.id, minimock.Diff(*mm_want_ptrs.id, mm_got.id))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("StorageInterfaceMock.Delete got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDelete.DeleteMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the StorageInterfaceMock.Delete")
		}
		return (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(ctx, id)
	}
	mmDelete.t.Fatalf("Unexpected call to StorageInterfaceMock.Delete. %v %v", ctx, id)
	return
}

// DeleteAfterCounter returns a count of finished StorageInterfaceMock.Delete invocations
func (mmDelete *StorageInterfaceMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of StorageInterfaceMock.Delete invocations
func (mmDelete *StorageInterfaceMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to StorageInterfaceMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mStorageInterfaceMockDelete) Calls() []*StorageInterfaceMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*StorageInterfaceMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *StorageInterfaceMock) MinimockDeleteDone() bool {
	if m.DeleteMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteMock.invocationsDone()
}

// MinimockDeleteInspect logs each unmet expectation
func (m *StorageInterfaceMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageInterfaceMock.Delete at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteCounter := mm_atomic.LoadUint64(&m.afterDeleteCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && afterDeleteCounter < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageInterfaceMock.Delete at\n%s", m.DeleteMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageInterfaceMock.Delete at\n%s with params: %#v", m.DeleteMock.defaultExpectation.expectationOrigins.origin, *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && afterDeleteCounter < 1 {
		m.t.Errorf("Expected call to StorageInterfaceMock.Delete at\n%s", m.funcDeleteOrigin)
	}

	if !m.DeleteMock.invocationsDone() && afterDeleteCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageInterfaceMock.Delete at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteMock.expectedInvocations), m.DeleteMock.expectedInvocationsOrigin, afterDeleteCounter)
	}
}

type mStorageInterfaceMockGetUser struct {
	optional           bool
	mock               *StorageInterfaceMock
	defaultExpectation *StorageInterfaceMockGetUserExpectation
	expectations       []*StorageInterfaceMockGetUserExpectation

	callArgs []*StorageInterfaceMockGetUserParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageInterfaceMockGetUserExpectation specifies expectation struct of the StorageInterface.GetUser
type StorageInterfaceMockGetUserExpectation struct {
	mock               *StorageInterfaceMock
	params             *StorageInterfaceMockGetUserParams
	paramPtrs          *StorageInterfaceMockGetUserParamPtrs
	expectationOrigins StorageInterfaceMockGetUserExpectationOrigins
	results            *StorageInterfaceMockGetUserResults
	returnOrigin       string
	Counter            uint64
}

// StorageInterfaceMockGetUserParams contains parameters of the StorageInterface.GetUser
type StorageInterfaceMockGetUserParams struct {
	ctx    context.Context
	params models.GetUserParams
}

// StorageInterfaceMockGetUserParamPtrs contains pointers to parameters of the StorageInterface.GetUser
type StorageInterfaceMockGetUserParamPtrs struct {
	ctx    *context.Context
	params *models.GetUserParams
}

// StorageInterfaceMockGetUserResults contains results of the StorageInterface.GetUser
type StorageInterfaceMockGetUserResults struct {
	up1 *models.User
	err error
}

// StorageInterfaceMockGetUserOrigins contains origins of expectations of the StorageInterface.GetUser
type StorageInterfaceMockGetUserExpectationOrigins struct {
	origin       string
	originCtx    string
	originParams string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetUser *mStorageInterfaceMockGetUser) Optional() *mStorageInterfaceMockGetUser {
	mmGetUser.optional = true
	return mmGetUser
}

// Expect sets up expected params for StorageInterface.GetUser
func (mmGetUser *mStorageInterfaceMockGetUser) Expect(ctx context.Context, params models.GetUserParams) *mStorageInterfaceMockGetUser {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("StorageInterfaceMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &StorageInterfaceMockGetUserExpectation{}
	}

	if mmGetUser.defaultExpectation.paramPtrs != nil {
		mmGetUser.mock.t.Fatalf("StorageInterfaceMock.GetUser mock is already set by ExpectParams functions")
	}

	mmGetUser.defaultExpectation.params = &StorageInterfaceMockGetUserParams{ctx, params}
	mmGetUser.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetUser.expectations {
		if minimock.Equal(e.params, mmGetUser.defaultExpectation.params) {
			mmGetUser.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetUser.defaultExpectation.params)
		}
	}

	return mmGetUser
}

// ExpectCtxParam1 sets up expected param ctx for StorageInterface.GetUser
func (mmGetUser *mStorageInterfaceMockGetUser) ExpectCtxParam1(ctx context.Context) *mStorageInterfaceMockGetUser {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("StorageInterfaceMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &StorageInterfaceMockGetUserExpectation{}
	}

	if mmGetUser.defaultExpectation.params != nil {
		mmGetUser.mock.t.Fatalf("StorageInterfaceMock.GetUser mock is already set by Expect")
	}

	if mmGetUser.defaultExpectation.paramPtrs == nil {
		mmGetUser.defaultExpectation.paramPtrs = &StorageInterfaceMockGetUserParamPtrs{}
	}
	mmGetUser.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetUser.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetUser
}

// ExpectParamsParam2 sets up expected param params for StorageInterface.GetUser
func (mmGetUser *mStorageInterfaceMockGetUser) ExpectParamsParam2(params models.GetUserParams) *mStorageInterfaceMockGetUser {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("StorageInterfaceMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &StorageInterfaceMockGetUserExpectation{}
	}

	if mmGetUser.defaultExpectation.params != nil {
		mmGetUser.mock.t.Fatalf("StorageInterfaceMock.GetUser mock is already set by Expect")
	}

	if mmGetUser.defaultExpectation.paramPtrs == nil {
		mmGetUser.defaultExpectation.paramPtrs = &StorageInterfaceMockGetUserParamPtrs{}
	}
	mmGetUser.defaultExpectation.paramPtrs.params = &params
	mmGetUser.defaultExpectation.expectationOrigins.originParams = minimock.CallerInfo(1)

	return mmGetUser
}

// Inspect accepts an inspector function that has same arguments as the StorageInterface.GetUser
func (mmGetUser *mStorageInterfaceMockGetUser) Inspect(f func(ctx context.Context, params models.GetUserParams)) *mStorageInterfaceMockGetUser {
	if mmGetUser.mock.inspectFuncGetUser != nil {
		mmGetUser.mock.t.Fatalf("Inspect function is already set for StorageInterfaceMock.GetUser")
	}

	mmGetUser.mock.inspectFuncGetUser = f

	return mmGetUser
}

// Return sets up results that will be returned by StorageInterface.GetUser
func (mmGetUser *mStorageInterfaceMockGetUser) Return(up1 *models.User, err error) *StorageInterfaceMock {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("StorageInterfaceMock.GetUser mock is already set by Set")
	}

	if mmGetUser.defaultExpectation == nil {
		mmGetUser.defaultExpectation = &StorageInterfaceMockGetUserExpectation{mock: mmGetUser.mock}
	}
	mmGetUser.defaultExpectation.results = &StorageInterfaceMockGetUserResults{up1, err}
	mmGetUser.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetUser.mock
}

// Set uses given function f to mock the StorageInterface.GetUser method
func (mmGetUser *mStorageInterfaceMockGetUser) Set(f func(ctx context.Context, params models.GetUserParams) (up1 *models.User, err error)) *StorageInterfaceMock {
	if mmGetUser.defaultExpectation != nil {
		mmGetUser.mock.t.Fatalf("Default expectation is already set for the StorageInterface.GetUser method")
	}

	if len(mmGetUser.expectations) > 0 {
		mmGetUser.mock.t.Fatalf("Some expectations are already set for the StorageInterface.GetUser method")
	}

	mmGetUser.mock.funcGetUser = f
	mmGetUser.mock.funcGetUserOrigin = minimock.CallerInfo(1)
	return mmGetUser.mock
}

// When sets expectation for the StorageInterface.GetUser which will trigger the result defined by the following
// Then helper
func (mmGetUser *mStorageInterfaceMockGetUser) When(ctx context.Context, params models.GetUserParams) *StorageInterfaceMockGetUserExpectation {
	if mmGetUser.mock.funcGetUser != nil {
		mmGetUser.mock.t.Fatalf("StorageInterfaceMock.GetUser mock is already set by Set")
	}

	expectation := &StorageInterfaceMockGetUserExpectation{
		mock:               mmGetUser.mock,
		params:             &StorageInterfaceMockGetUserParams{ctx, params},
		expectationOrigins: StorageInterfaceMockGetUserExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetUser.expectations = append(mmGetUser.expectations, expectation)
	return expectation
}

// Then sets up StorageInterface.GetUser return parameters for the expectation previously defined by the When method
func (e *StorageInterfaceMockGetUserExpectation) Then(up1 *models.User, err error) *StorageInterfaceMock {
	e.results = &StorageInterfaceMockGetUserResults{up1, err}
	return e.mock
}

// Times sets number of times StorageInterface.GetUser should be invoked
func (mmGetUser *mStorageInterfaceMockGetUser) Times(n uint64) *mStorageInterfaceMockGetUser {
	if n == 0 {
		mmGetUser.mock.t.Fatalf("Times of StorageInterfaceMock.GetUser mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetUser.expectedInvocations, n)
	mmGetUser.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetUser
}

func (mmGetUser *mStorageInterfaceMockGetUser) invocationsDone() bool {
	if len(mmGetUser.expectations) == 0 && mmGetUser.defaultExpectation == nil && mmGetUser.mock.funcGetUser == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetUser.mock.afterGetUserCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetUser.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetUser implements mm_repoInterface.StorageInterface
func (mmGetUser *StorageInterfaceMock) GetUser(ctx context.Context, params models.GetUserParams) (up1 *models.User, err error) {
	mm_atomic.AddUint64(&mmGetUser.beforeGetUserCounter, 1)
	defer mm_atomic.AddUint64(&mmGetUser.afterGetUserCounter, 1)

	mmGetUser.t.Helper()

	if mmGetUser.inspectFuncGetUser != nil {
		mmGetUser.inspectFuncGetUser(ctx, params)
	}

	mm_params := StorageInterfaceMockGetUserParams{ctx, params}

	// Record call args
	mmGetUser.GetUserMock.mutex.Lock()
	mmGetUser.GetUserMock.callArgs = append(mmGetUser.GetUserMock.callArgs, &mm_params)
	mmGetUser.GetUserMock.mutex.Unlock()

	for _, e := range mmGetUser.GetUserMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmGetUser.GetUserMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetUser.GetUserMock.defaultExpectation.Counter, 1)
		mm_want := mmGetUser.GetUserMock.defaultExpectation.params
		mm_want_ptrs := mmGetUser.GetUserMock.defaultExpectation.paramPtrs

		mm_got := StorageInterfaceMockGetUserParams{ctx, params}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetUser.t.Errorf("StorageInterfaceMock.GetUser got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUser.GetUserMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.params != nil && !minimock.Equal(*mm_want_ptrs.params, mm_got.params) {
				mmGetUser.t.Errorf("StorageInterfaceMock.GetUser got unexpected parameter params, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetUser.GetUserMock.defaultExpectation.expectationOrigins.originParams, *mm_want_ptrs.params, mm_got.params, minimock.Diff(*mm_want_ptrs.params, mm_got.params))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetUser.t.Errorf("StorageInterfaceMock.GetUser got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetUser.GetUserMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetUser.GetUserMock.defaultExpectation.results
		if mm_results == nil {
			mmGetUser.t.Fatal("No results are set for the StorageInterfaceMock.GetUser")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmGetUser.funcGetUser != nil {
		return mmGetUser.funcGetUser(ctx, params)
	}
	mmGetUser.t.Fatalf("Unexpected call to StorageInterfaceMock.GetUser. %v %v", ctx, params)
	return
}

// GetUserAfterCounter returns a count of finished StorageInterfaceMock.GetUser invocations
func (mmGetUser *StorageInterfaceMock) GetUserAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUser.afterGetUserCounter)
}

// GetUserBeforeCounter returns a count of StorageInterfaceMock.GetUser invocations
func (mmGetUser *StorageInterfaceMock) GetUserBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetUser.beforeGetUserCounter)
}

// Calls returns a list of arguments used in each call to StorageInterfaceMock.GetUser.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetUser *mStorageInterfaceMockGetUser) Calls() []*StorageInterfaceMockGetUserParams {
	mmGetUser.mutex.RLock()

	argCopy := make([]*StorageInterfaceMockGetUserParams, len(mmGetUser.callArgs))
	copy(argCopy, mmGetUser.callArgs)

	mmGetUser.mutex.RUnlock()

	return argCopy
}

// MinimockGetUserDone returns true if the count of the GetUser invocations corresponds
// the number of defined expectations
func (m *StorageInterfaceMock) MinimockGetUserDone() bool {
	if m.GetUserMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetUserMock.invocationsDone()
}

// MinimockGetUserInspect logs each unmet expectation
func (m *StorageInterfaceMock) MinimockGetUserInspect() {
	for _, e := range m.GetUserMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageInterfaceMock.GetUser at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetUserCounter := mm_atomic.LoadUint64(&m.afterGetUserCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetUserMock.defaultExpectation != nil && afterGetUserCounter < 1 {
		if m.GetUserMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageInterfaceMock.GetUser at\n%s", m.GetUserMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageInterfaceMock.GetUser at\n%s with params: %#v", m.GetUserMock.defaultExpectation.expectationOrigins.origin, *m.GetUserMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetUser != nil && afterGetUserCounter < 1 {
		m.t.Errorf("Expected call to StorageInterfaceMock.GetUser at\n%s", m.funcGetUserOrigin)
	}

	if !m.GetUserMock.invocationsDone() && afterGetUserCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageInterfaceMock.GetUser at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetUserMock.expectedInvocations), m.GetUserMock.expectedInvocationsOrigin, afterGetUserCounter)
	}
}

type mStorageInterfaceMockLog struct {
	optional           bool
	mock               *StorageInterfaceMock
	defaultExpectation *StorageInterfaceMockLogExpectation
	expectations       []*StorageInterfaceMockLogExpectation

	callArgs []*StorageInterfaceMockLogParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageInterfaceMockLogExpectation specifies expectation struct of the StorageInterface.Log
type StorageInterfaceMockLogExpectation struct {
	mock               *StorageInterfaceMock
	params             *StorageInterfaceMockLogParams
	paramPtrs          *StorageInterfaceMockLogParamPtrs
	expectationOrigins StorageInterfaceMockLogExpectationOrigins
	results            *StorageInterfaceMockLogResults
	returnOrigin       string
	Counter            uint64
}

// StorageInterfaceMockLogParams contains parameters of the StorageInterface.Log
type StorageInterfaceMockLogParams struct {
	ctx context.Context
	key models.LogKey
}

// StorageInterfaceMockLogParamPtrs contains pointers to parameters of the StorageInterface.Log
type StorageInterfaceMockLogParamPtrs struct {
	ctx *context.Context
	key *models.LogKey
}

// StorageInterfaceMockLogResults contains results of the StorageInterface.Log
type StorageInterfaceMockLogResults struct {
	err error
}

// StorageInterfaceMockLogOrigins contains origins of expectations of the StorageInterface.Log
type StorageInterfaceMockLogExpectationOrigins struct {
	origin    string
	originCtx string
	originKey string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmLog *mStorageInterfaceMockLog) Optional() *mStorageInterfaceMockLog {
	mmLog.optional = true
	return mmLog
}

// Expect sets up expected params for StorageInterface.Log
func (mmLog *mStorageInterfaceMockLog) Expect(ctx context.Context, key models.LogKey) *mStorageInterfaceMockLog {
	if mmLog.mock.funcLog != nil {
		mmLog.mock.t.Fatalf("StorageInterfaceMock.Log mock is already set by Set")
	}

	if mmLog.defaultExpectation == nil {
		mmLog.defaultExpectation = &StorageInterfaceMockLogExpectation{}
	}

	if mmLog.defaultExpectation.paramPtrs != nil {
		mmLog.mock.t.Fatalf("StorageInterfaceMock.Log mock is already set by ExpectParams functions")
	}

	mmLog.defaultExpectation.params = &StorageInterfaceMockLogParams{ctx, key}
	mmLog.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmLog.expectations {
		if minimock.Equal(e.params, mmLog.defaultExpectation.params) {
			mmLog.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmLog.defaultExpectation.params)
		}
	}

	return mmLog
}

// ExpectCtxParam1 sets up expected param ctx for StorageInterface.Log
func (mmLog *mStorageInterfaceMockLog) ExpectCtxParam1(ctx context.Context) *mStorageInterfaceMockLog {
	if mmLog.mock.funcLog != nil {
		mmLog.mock.t.Fatalf("StorageInterfaceMock.Log mock is already set by Set")
	}

	if mmLog.defaultExpectation == nil {
		mmLog.defaultExpectation = &StorageInterfaceMockLogExpectation{}
	}

	if mmLog.defaultExpectation.params != nil {
		mmLog.mock.t.Fatalf("StorageInterfaceMock.Log mock is already set by Expect")
	}

	if mmLog.defaultExpectation.paramPtrs == nil {
		mmLog.defaultExpectation.paramPtrs = &StorageInterfaceMockLogParamPtrs{}
	}
	mmLog.defaultExpectation.paramPtrs.ctx = &ctx
	mmLog.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmLog
}

// ExpectKeyParam2 sets up expected param key for StorageInterface.Log
func (mmLog *mStorageInterfaceMockLog) ExpectKeyParam2(key models.LogKey) *mStorageInterfaceMockLog {
	if mmLog.mock.funcLog != nil {
		mmLog.mock.t.Fatalf("StorageInterfaceMock.Log mock is already set by Set")
	}

	if mmLog.defaultExpectation == nil {
		mmLog.defaultExpectation = &StorageInterfaceMockLogExpectation{}
	}

	if mmLog.defaultExpectation.params != nil {
		mmLog.mock.t.Fatalf("StorageInterfaceMock.Log mock is already set by Expect")
	}

	if mmLog.defaultExpectation.paramPtrs == nil {
		mmLog.defaultExpectation.paramPtrs = &StorageInterfaceMockLogParamPtrs{}
	}
	mmLog.defaultExpectation.paramPtrs.key = &key
	mmLog.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

	return mmLog
}

// Inspect accepts an inspector function that has same arguments as the StorageInterface.Log
func (mmLog *mStorageInterfaceMockLog) Inspect(f func(ctx context.Context, key models.LogKey)) *mStorageInterfaceMockLog {
	if mmLog.mock.inspectFuncLog != nil {
		mmLog.mock.t.Fatalf("Inspect function is already set for StorageInterfaceMock.Log")
	}

	mmLog.mock.inspectFuncLog = f

	return mmLog
}

// Return sets up results that will be returned by StorageInterface.Log
func (mmLog *mStorageInterfaceMockLog) Return(err error) *StorageInterfaceMock {
	if mmLog.mock.funcLog != nil {
		mmLog.mock.t.Fatalf("StorageInterfaceMock.Log mock is already set by Set")
	}

	if mmLog.defaultExpectation == nil {
		mmLog.defaultExpectation = &StorageInterfaceMockLogExpectation{mock: mmLog.mock}
	}
	mmLog.defaultExpectation.results = &StorageInterfaceMockLogResults{err}
	mmLog.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmLog.mock
}

// Set uses given function f to mock the StorageInterface.Log method
func (mmLog *mStorageInterfaceMockLog) Set(f func(ctx context.Context, key models.LogKey) (err error)) *StorageInterfaceMock {
	if mmLog.defaultExpectation != nil {
		mmLog.mock.t.Fatalf("Default expectation is already set for the StorageInterface.Log method")
	}

	if len(mmLog.expectations) > 0 {
		mmLog.mock.t.Fatalf("Some expectations are already set for the StorageInterface.Log method")
	}

	mmLog.mock.funcLog = f
	mmLog.mock.funcLogOrigin = minimock.CallerInfo(1)
	return mmLog.mock
}

// When sets expectation for the StorageInterface.Log which will trigger the result defined by the following
// Then helper
func (mmLog *mStorageInterfaceMockLog) When(ctx context.Context, key models.LogKey) *StorageInterfaceMockLogExpectation {
	if mmLog.mock.funcLog != nil {
		mmLog.mock.t.Fatalf("StorageInterfaceMock.Log mock is already set by Set")
	}

	expectation := &StorageInterfaceMockLogExpectation{
		mock:               mmLog.mock,
		params:             &StorageInterfaceMockLogParams{ctx, key},
		expectationOrigins: StorageInterfaceMockLogExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmLog.expectations = append(mmLog.expectations, expectation)
	return expectation
}

// Then sets up StorageInterface.Log return parameters for the expectation previously defined by the When method
func (e *StorageInterfaceMockLogExpectation) Then(err error) *StorageInterfaceMock {
	e.results = &StorageInterfaceMockLogResults{err}
	return e.mock
}

// Times sets number of times StorageInterface.Log should be invoked
func (mmLog *mStorageInterfaceMockLog) Times(n uint64) *mStorageInterfaceMockLog {
	if n == 0 {
		mmLog.mock.t.Fatalf("Times of StorageInterfaceMock.Log mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmLog.expectedInvocations, n)
	mmLog.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmLog
}

func (mmLog *mStorageInterfaceMockLog) invocationsDone() bool {
	if len(mmLog.expectations) == 0 && mmLog.defaultExpectation == nil && mmLog.mock.funcLog == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmLog.mock.afterLogCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmLog.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Log implements mm_repoInterface.StorageInterface
func (mmLog *StorageInterfaceMock) Log(ctx context.Context, key models.LogKey) (err error) {
	mm_atomic.AddUint64(&mmLog.beforeLogCounter, 1)
	defer mm_atomic.AddUint64(&mmLog.afterLogCounter, 1)

	mmLog.t.Helper()

	if mmLog.inspectFuncLog != nil {
		mmLog.inspectFuncLog(ctx, key)
	}

	mm_params := StorageInterfaceMockLogParams{ctx, key}

	// Record call args
	mmLog.LogMock.mutex.Lock()
	mmLog.LogMock.callArgs = append(mmLog.LogMock.callArgs, &mm_params)
	mmLog.LogMock.mutex.Unlock()

	for _, e := range mmLog.LogMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmLog.LogMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLog.LogMock.defaultExpectation.Counter, 1)
		mm_want := mmLog.LogMock.defaultExpectation.params
		mm_want_ptrs := mmLog.LogMock.defaultExpectation.paramPtrs

		mm_got := StorageInterfaceMockLogParams{ctx, key}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmLog.t.Errorf("StorageInterfaceMock.Log got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmLog.LogMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmLog.t.Errorf("StorageInterfaceMock.Log got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmLog.LogMock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmLog.t.Errorf("StorageInterfaceMock.Log got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmLog.LogMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmLog.LogMock.defaultExpectation.results
		if mm_results == nil {
			mmLog.t.Fatal("No results are set for the StorageInterfaceMock.Log")
		}
		return (*mm_results).err
	}
	if mmLog.funcLog != nil {
		return mmLog.funcLog(ctx, key)
	}
	mmLog.t.Fatalf("Unexpected call to StorageInterfaceMock.Log. %v %v", ctx, key)
	return
}

// LogAfterCounter returns a count of finished StorageInterfaceMock.Log invocations
func (mmLog *StorageInterfaceMock) LogAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLog.afterLogCounter)
}

// LogBeforeCounter returns a count of StorageInterfaceMock.Log invocations
func (mmLog *StorageInterfaceMock) LogBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLog.beforeLogCounter)
}

// Calls returns a list of arguments used in each call to StorageInterfaceMock.Log.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmLog *mStorageInterfaceMockLog) Calls() []*StorageInterfaceMockLogParams {
	mmLog.mutex.RLock()

	argCopy := make([]*StorageInterfaceMockLogParams, len(mmLog.callArgs))
	copy(argCopy, mmLog.callArgs)

	mmLog.mutex.RUnlock()

	return argCopy
}

// MinimockLogDone returns true if the count of the Log invocations corresponds
// the number of defined expectations
func (m *StorageInterfaceMock) MinimockLogDone() bool {
	if m.LogMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.LogMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.LogMock.invocationsDone()
}

// MinimockLogInspect logs each unmet expectation
func (m *StorageInterfaceMock) MinimockLogInspect() {
	for _, e := range m.LogMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageInterfaceMock.Log at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterLogCounter := mm_atomic.LoadUint64(&m.afterLogCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.LogMock.defaultExpectation != nil && afterLogCounter < 1 {
		if m.LogMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageInterfaceMock.Log at\n%s", m.LogMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageInterfaceMock.Log at\n%s with params: %#v", m.LogMock.defaultExpectation.expectationOrigins.origin, *m.LogMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLog != nil && afterLogCounter < 1 {
		m.t.Errorf("Expected call to StorageInterfaceMock.Log at\n%s", m.funcLogOrigin)
	}

	if !m.LogMock.invocationsDone() && afterLogCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageInterfaceMock.Log at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.LogMock.expectedInvocations), m.LogMock.expectedInvocationsOrigin, afterLogCounter)
	}
}

type mStorageInterfaceMockSave struct {
	optional           bool
	mock               *StorageInterfaceMock
	defaultExpectation *StorageInterfaceMockSaveExpectation
	expectations       []*StorageInterfaceMockSaveExpectation

	callArgs []*StorageInterfaceMockSaveParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageInterfaceMockSaveExpectation specifies expectation struct of the StorageInterface.Save
type StorageInterfaceMockSaveExpectation struct {
	mock               *StorageInterfaceMock
	params             *StorageInterfaceMockSaveParams
	paramPtrs          *StorageInterfaceMockSaveParamPtrs
	expectationOrigins StorageInterfaceMockSaveExpectationOrigins
	results            *StorageInterfaceMockSaveResults
	returnOrigin       string
	Counter            uint64
}

// StorageInterfaceMockSaveParams contains parameters of the StorageInterface.Save
type StorageInterfaceMockSaveParams struct {
	ctx  context.Context
	user models.User
}

// StorageInterfaceMockSaveParamPtrs contains pointers to parameters of the StorageInterface.Save
type StorageInterfaceMockSaveParamPtrs struct {
	ctx  *context.Context
	user *models.User
}

// StorageInterfaceMockSaveResults contains results of the StorageInterface.Save
type StorageInterfaceMockSaveResults struct {
	i1  int64
	err error
}

// StorageInterfaceMockSaveOrigins contains origins of expectations of the StorageInterface.Save
type StorageInterfaceMockSaveExpectationOrigins struct {
	origin     string
	originCtx  string
	originUser string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSave *mStorageInterfaceMockSave) Optional() *mStorageInterfaceMockSave {
	mmSave.optional = true
	return mmSave
}

// Expect sets up expected params for StorageInterface.Save
func (mmSave *mStorageInterfaceMockSave) Expect(ctx context.Context, user models.User) *mStorageInterfaceMockSave {
	if mmSave.mock.funcSave != nil {
		mmSave.mock.t.Fatalf("StorageInterfaceMock.Save mock is already set by Set")
	}

	if mmSave.defaultExpectation == nil {
		mmSave.defaultExpectation = &StorageInterfaceMockSaveExpectation{}
	}

	if mmSave.defaultExpectation.paramPtrs != nil {
		mmSave.mock.t.Fatalf("StorageInterfaceMock.Save mock is already set by ExpectParams functions")
	}

	mmSave.defaultExpectation.params = &StorageInterfaceMockSaveParams{ctx, user}
	mmSave.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSave.expectations {
		if minimock.Equal(e.params, mmSave.defaultExpectation.params) {
			mmSave.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSave.defaultExpectation.params)
		}
	}

	return mmSave
}

// ExpectCtxParam1 sets up expected param ctx for StorageInterface.Save
func (mmSave *mStorageInterfaceMockSave) ExpectCtxParam1(ctx context.Context) *mStorageInterfaceMockSave {
	if mmSave.mock.funcSave != nil {
		mmSave.mock.t.Fatalf("StorageInterfaceMock.Save mock is already set by Set")
	}

	if mmSave.defaultExpectation == nil {
		mmSave.defaultExpectation = &StorageInterfaceMockSaveExpectation{}
	}

	if mmSave.defaultExpectation.params != nil {
		mmSave.mock.t.Fatalf("StorageInterfaceMock.Save mock is already set by Expect")
	}

	if mmSave.defaultExpectation.paramPtrs == nil {
		mmSave.defaultExpectation.paramPtrs = &StorageInterfaceMockSaveParamPtrs{}
	}
	mmSave.defaultExpectation.paramPtrs.ctx = &ctx
	mmSave.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSave
}

// ExpectUserParam2 sets up expected param user for StorageInterface.Save
func (mmSave *mStorageInterfaceMockSave) ExpectUserParam2(user models.User) *mStorageInterfaceMockSave {
	if mmSave.mock.funcSave != nil {
		mmSave.mock.t.Fatalf("StorageInterfaceMock.Save mock is already set by Set")
	}

	if mmSave.defaultExpectation == nil {
		mmSave.defaultExpectation = &StorageInterfaceMockSaveExpectation{}
	}

	if mmSave.defaultExpectation.params != nil {
		mmSave.mock.t.Fatalf("StorageInterfaceMock.Save mock is already set by Expect")
	}

	if mmSave.defaultExpectation.paramPtrs == nil {
		mmSave.defaultExpectation.paramPtrs = &StorageInterfaceMockSaveParamPtrs{}
	}
	mmSave.defaultExpectation.paramPtrs.user = &user
	mmSave.defaultExpectation.expectationOrigins.originUser = minimock.CallerInfo(1)

	return mmSave
}

// Inspect accepts an inspector function that has same arguments as the StorageInterface.Save
func (mmSave *mStorageInterfaceMockSave) Inspect(f func(ctx context.Context, user models.User)) *mStorageInterfaceMockSave {
	if mmSave.mock.inspectFuncSave != nil {
		mmSave.mock.t.Fatalf("Inspect function is already set for StorageInterfaceMock.Save")
	}

	mmSave.mock.inspectFuncSave = f

	return mmSave
}

// Return sets up results that will be returned by StorageInterface.Save
func (mmSave *mStorageInterfaceMockSave) Return(i1 int64, err error) *StorageInterfaceMock {
	if mmSave.mock.funcSave != nil {
		mmSave.mock.t.Fatalf("StorageInterfaceMock.Save mock is already set by Set")
	}

	if mmSave.defaultExpectation == nil {
		mmSave.defaultExpectation = &StorageInterfaceMockSaveExpectation{mock: mmSave.mock}
	}
	mmSave.defaultExpectation.results = &StorageInterfaceMockSaveResults{i1, err}
	mmSave.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSave.mock
}

// Set uses given function f to mock the StorageInterface.Save method
func (mmSave *mStorageInterfaceMockSave) Set(f func(ctx context.Context, user models.User) (i1 int64, err error)) *StorageInterfaceMock {
	if mmSave.defaultExpectation != nil {
		mmSave.mock.t.Fatalf("Default expectation is already set for the StorageInterface.Save method")
	}

	if len(mmSave.expectations) > 0 {
		mmSave.mock.t.Fatalf("Some expectations are already set for the StorageInterface.Save method")
	}

	mmSave.mock.funcSave = f
	mmSave.mock.funcSaveOrigin = minimock.CallerInfo(1)
	return mmSave.mock
}

// When sets expectation for the StorageInterface.Save which will trigger the result defined by the following
// Then helper
func (mmSave *mStorageInterfaceMockSave) When(ctx context.Context, user models.User) *StorageInterfaceMockSaveExpectation {
	if mmSave.mock.funcSave != nil {
		mmSave.mock.t.Fatalf("StorageInterfaceMock.Save mock is already set by Set")
	}

	expectation := &StorageInterfaceMockSaveExpectation{
		mock:               mmSave.mock,
		params:             &StorageInterfaceMockSaveParams{ctx, user},
		expectationOrigins: StorageInterfaceMockSaveExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSave.expectations = append(mmSave.expectations, expectation)
	return expectation
}

// Then sets up StorageInterface.Save return parameters for the expectation previously defined by the When method
func (e *StorageInterfaceMockSaveExpectation) Then(i1 int64, err error) *StorageInterfaceMock {
	e.results = &StorageInterfaceMockSaveResults{i1, err}
	return e.mock
}

// Times sets number of times StorageInterface.Save should be invoked
func (mmSave *mStorageInterfaceMockSave) Times(n uint64) *mStorageInterfaceMockSave {
	if n == 0 {
		mmSave.mock.t.Fatalf("Times of StorageInterfaceMock.Save mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSave.expectedInvocations, n)
	mmSave.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSave
}

func (mmSave *mStorageInterfaceMockSave) invocationsDone() bool {
	if len(mmSave.expectations) == 0 && mmSave.defaultExpectation == nil && mmSave.mock.funcSave == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSave.mock.afterSaveCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSave.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Save implements mm_repoInterface.StorageInterface
func (mmSave *StorageInterfaceMock) Save(ctx context.Context, user models.User) (i1 int64, err error) {
	mm_atomic.AddUint64(&mmSave.beforeSaveCounter, 1)
	defer mm_atomic.AddUint64(&mmSave.afterSaveCounter, 1)

	mmSave.t.Helper()

	if mmSave.inspectFuncSave != nil {
		mmSave.inspectFuncSave(ctx, user)
	}

	mm_params := StorageInterfaceMockSaveParams{ctx, user}

	// Record call args
	mmSave.SaveMock.mutex.Lock()
	mmSave.SaveMock.callArgs = append(mmSave.SaveMock.callArgs, &mm_params)
	mmSave.SaveMock.mutex.Unlock()

	for _, e := range mmSave.SaveMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmSave.SaveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSave.SaveMock.defaultExpectation.Counter, 1)
		mm_want := mmSave.SaveMock.defaultExpectation.params
		mm_want_ptrs := mmSave.SaveMock.defaultExpectation.paramPtrs

		mm_got := StorageInterfaceMockSaveParams{ctx, user}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSave.t.Errorf("StorageInterfaceMock.Save got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSave.SaveMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.user != nil && !minimock.Equal(*mm_want_ptrs.user, mm_got.user) {
				mmSave.t.Errorf("StorageInterfaceMock.Save got unexpected parameter user, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSave.SaveMock.defaultExpectation.expectationOrigins.originUser, *mm_want_ptrs.user, mm_got.user, minimock.Diff(*mm_want_ptrs.user, mm_got.user))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSave.t.Errorf("StorageInterfaceMock.Save got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSave.SaveMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSave.SaveMock.defaultExpectation.results
		if mm_results == nil {
			mmSave.t.Fatal("No results are set for the StorageInterfaceMock.Save")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmSave.funcSave != nil {
		return mmSave.funcSave(ctx, user)
	}
	mmSave.t.Fatalf("Unexpected call to StorageInterfaceMock.Save. %v %v", ctx, user)
	return
}

// SaveAfterCounter returns a count of finished StorageInterfaceMock.Save invocations
func (mmSave *StorageInterfaceMock) SaveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSave.afterSaveCounter)
}

// SaveBeforeCounter returns a count of StorageInterfaceMock.Save invocations
func (mmSave *StorageInterfaceMock) SaveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSave.beforeSaveCounter)
}

// Calls returns a list of arguments used in each call to StorageInterfaceMock.Save.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSave *mStorageInterfaceMockSave) Calls() []*StorageInterfaceMockSaveParams {
	mmSave.mutex.RLock()

	argCopy := make([]*StorageInterfaceMockSaveParams, len(mmSave.callArgs))
	copy(argCopy, mmSave.callArgs)

	mmSave.mutex.RUnlock()

	return argCopy
}

// MinimockSaveDone returns true if the count of the Save invocations corresponds
// the number of defined expectations
func (m *StorageInterfaceMock) MinimockSaveDone() bool {
	if m.SaveMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SaveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SaveMock.invocationsDone()
}

// MinimockSaveInspect logs each unmet expectation
func (m *StorageInterfaceMock) MinimockSaveInspect() {
	for _, e := range m.SaveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageInterfaceMock.Save at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSaveCounter := mm_atomic.LoadUint64(&m.afterSaveCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SaveMock.defaultExpectation != nil && afterSaveCounter < 1 {
		if m.SaveMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageInterfaceMock.Save at\n%s", m.SaveMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageInterfaceMock.Save at\n%s with params: %#v", m.SaveMock.defaultExpectation.expectationOrigins.origin, *m.SaveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSave != nil && afterSaveCounter < 1 {
		m.t.Errorf("Expected call to StorageInterfaceMock.Save at\n%s", m.funcSaveOrigin)
	}

	if !m.SaveMock.invocationsDone() && afterSaveCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageInterfaceMock.Save at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SaveMock.expectedInvocations), m.SaveMock.expectedInvocationsOrigin, afterSaveCounter)
	}
}

type mStorageInterfaceMockUpdate struct {
	optional           bool
	mock               *StorageInterfaceMock
	defaultExpectation *StorageInterfaceMockUpdateExpectation
	expectations       []*StorageInterfaceMockUpdateExpectation

	callArgs []*StorageInterfaceMockUpdateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// StorageInterfaceMockUpdateExpectation specifies expectation struct of the StorageInterface.Update
type StorageInterfaceMockUpdateExpectation struct {
	mock               *StorageInterfaceMock
	params             *StorageInterfaceMockUpdateParams
	paramPtrs          *StorageInterfaceMockUpdateParamPtrs
	expectationOrigins StorageInterfaceMockUpdateExpectationOrigins
	results            *StorageInterfaceMockUpdateResults
	returnOrigin       string
	Counter            uint64
}

// StorageInterfaceMockUpdateParams contains parameters of the StorageInterface.Update
type StorageInterfaceMockUpdateParams struct {
	ctx    context.Context
	update models.User
}

// StorageInterfaceMockUpdateParamPtrs contains pointers to parameters of the StorageInterface.Update
type StorageInterfaceMockUpdateParamPtrs struct {
	ctx    *context.Context
	update *models.User
}

// StorageInterfaceMockUpdateResults contains results of the StorageInterface.Update
type StorageInterfaceMockUpdateResults struct {
	err error
}

// StorageInterfaceMockUpdateOrigins contains origins of expectations of the StorageInterface.Update
type StorageInterfaceMockUpdateExpectationOrigins struct {
	origin       string
	originCtx    string
	originUpdate string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdate *mStorageInterfaceMockUpdate) Optional() *mStorageInterfaceMockUpdate {
	mmUpdate.optional = true
	return mmUpdate
}

// Expect sets up expected params for StorageInterface.Update
func (mmUpdate *mStorageInterfaceMockUpdate) Expect(ctx context.Context, update models.User) *mStorageInterfaceMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("StorageInterfaceMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &StorageInterfaceMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.paramPtrs != nil {
		mmUpdate.mock.t.Fatalf("StorageInterfaceMock.Update mock is already set by ExpectParams functions")
	}

	mmUpdate.defaultExpectation.params = &StorageInterfaceMockUpdateParams{ctx, update}
	mmUpdate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdate.expectations {
		if minimock.Equal(e.params, mmUpdate.defaultExpectation.params) {
			mmUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdate.defaultExpectation.params)
		}
	}

	return mmUpdate
}

// ExpectCtxParam1 sets up expected param ctx for StorageInterface.Update
func (mmUpdate *mStorageInterfaceMockUpdate) ExpectCtxParam1(ctx context.Context) *mStorageInterfaceMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("StorageInterfaceMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &StorageInterfaceMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("StorageInterfaceMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &StorageInterfaceMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdate
}

// ExpectUpdateParam2 sets up expected param update for StorageInterface.Update
func (mmUpdate *mStorageInterfaceMockUpdate) ExpectUpdateParam2(update models.User) *mStorageInterfaceMockUpdate {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("StorageInterfaceMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &StorageInterfaceMockUpdateExpectation{}
	}

	if mmUpdate.defaultExpectation.params != nil {
		mmUpdate.mock.t.Fatalf("StorageInterfaceMock.Update mock is already set by Expect")
	}

	if mmUpdate.defaultExpectation.paramPtrs == nil {
		mmUpdate.defaultExpectation.paramPtrs = &StorageInterfaceMockUpdateParamPtrs{}
	}
	mmUpdate.defaultExpectation.paramPtrs.update = &update
	mmUpdate.defaultExpectation.expectationOrigins.originUpdate = minimock.CallerInfo(1)

	return mmUpdate
}

// Inspect accepts an inspector function that has same arguments as the StorageInterface.Update
func (mmUpdate *mStorageInterfaceMockUpdate) Inspect(f func(ctx context.Context, update models.User)) *mStorageInterfaceMockUpdate {
	if mmUpdate.mock.inspectFuncUpdate != nil {
		mmUpdate.mock.t.Fatalf("Inspect function is already set for StorageInterfaceMock.Update")
	}

	mmUpdate.mock.inspectFuncUpdate = f

	return mmUpdate
}

// Return sets up results that will be returned by StorageInterface.Update
func (mmUpdate *mStorageInterfaceMockUpdate) Return(err error) *StorageInterfaceMock {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("StorageInterfaceMock.Update mock is already set by Set")
	}

	if mmUpdate.defaultExpectation == nil {
		mmUpdate.defaultExpectation = &StorageInterfaceMockUpdateExpectation{mock: mmUpdate.mock}
	}
	mmUpdate.defaultExpectation.results = &StorageInterfaceMockUpdateResults{err}
	mmUpdate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdate.mock
}

// Set uses given function f to mock the StorageInterface.Update method
func (mmUpdate *mStorageInterfaceMockUpdate) Set(f func(ctx context.Context, update models.User) (err error)) *StorageInterfaceMock {
	if mmUpdate.defaultExpectation != nil {
		mmUpdate.mock.t.Fatalf("Default expectation is already set for the StorageInterface.Update method")
	}

	if len(mmUpdate.expectations) > 0 {
		mmUpdate.mock.t.Fatalf("Some expectations are already set for the StorageInterface.Update method")
	}

	mmUpdate.mock.funcUpdate = f
	mmUpdate.mock.funcUpdateOrigin = minimock.CallerInfo(1)
	return mmUpdate.mock
}

// When sets expectation for the StorageInterface.Update which will trigger the result defined by the following
// Then helper
func (mmUpdate *mStorageInterfaceMockUpdate) When(ctx context.Context, update models.User) *StorageInterfaceMockUpdateExpectation {
	if mmUpdate.mock.funcUpdate != nil {
		mmUpdate.mock.t.Fatalf("StorageInterfaceMock.Update mock is already set by Set")
	}

	expectation := &StorageInterfaceMockUpdateExpectation{
		mock:               mmUpdate.mock,
		params:             &StorageInterfaceMockUpdateParams{ctx, update},
		expectationOrigins: StorageInterfaceMockUpdateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdate.expectations = append(mmUpdate.expectations, expectation)
	return expectation
}

// Then sets up StorageInterface.Update return parameters for the expectation previously defined by the When method
func (e *StorageInterfaceMockUpdateExpectation) Then(err error) *StorageInterfaceMock {
	e.results = &StorageInterfaceMockUpdateResults{err}
	return e.mock
}

// Times sets number of times StorageInterface.Update should be invoked
func (mmUpdate *mStorageInterfaceMockUpdate) Times(n uint64) *mStorageInterfaceMockUpdate {
	if n == 0 {
		mmUpdate.mock.t.Fatalf("Times of StorageInterfaceMock.Update mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdate.expectedInvocations, n)
	mmUpdate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdate
}

func (mmUpdate *mStorageInterfaceMockUpdate) invocationsDone() bool {
	if len(mmUpdate.expectations) == 0 && mmUpdate.defaultExpectation == nil && mmUpdate.mock.funcUpdate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdate.mock.afterUpdateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Update implements mm_repoInterface.StorageInterface
func (mmUpdate *StorageInterfaceMock) Update(ctx context.Context, update models.User) (err error) {
	mm_atomic.AddUint64(&mmUpdate.beforeUpdateCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdate.afterUpdateCounter, 1)

	mmUpdate.t.Helper()

	if mmUpdate.inspectFuncUpdate != nil {
		mmUpdate.inspectFuncUpdate(ctx, update)
	}

	mm_params := StorageInterfaceMockUpdateParams{ctx, update}

	// Record call args
	mmUpdate.UpdateMock.mutex.Lock()
	mmUpdate.UpdateMock.callArgs = append(mmUpdate.UpdateMock.callArgs, &mm_params)
	mmUpdate.UpdateMock.mutex.Unlock()

	for _, e := range mmUpdate.UpdateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdate.UpdateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdate.UpdateMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdate.UpdateMock.defaultExpectation.params
		mm_want_ptrs := mmUpdate.UpdateMock.defaultExpectation.paramPtrs

		mm_got := StorageInterfaceMockUpdateParams{ctx, update}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdate.t.Errorf("StorageInterfaceMock.Update got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.update != nil && !minimock.Equal(*mm_want_ptrs.update, mm_got.update) {
				mmUpdate.t.Errorf("StorageInterfaceMock.Update got unexpected parameter update, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.originUpdate, *mm_want_ptrs.update, mm_got.update, minimock.Diff(*mm_want_ptrs.update, mm_got.update))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdate.t.Errorf("StorageInterfaceMock.Update got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdate.UpdateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdate.UpdateMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdate.t.Fatal("No results are set for the StorageInterfaceMock.Update")
		}
		return (*mm_results).err
	}
	if mmUpdate.funcUpdate != nil {
		return mmUpdate.funcUpdate(ctx, update)
	}
	mmUpdate.t.Fatalf("Unexpected call to StorageInterfaceMock.Update. %v %v", ctx, update)
	return
}

// UpdateAfterCounter returns a count of finished StorageInterfaceMock.Update invocations
func (mmUpdate *StorageInterfaceMock) UpdateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.afterUpdateCounter)
}

// UpdateBeforeCounter returns a count of StorageInterfaceMock.Update invocations
func (mmUpdate *StorageInterfaceMock) UpdateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdate.beforeUpdateCounter)
}

// Calls returns a list of arguments used in each call to StorageInterfaceMock.Update.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdate *mStorageInterfaceMockUpdate) Calls() []*StorageInterfaceMockUpdateParams {
	mmUpdate.mutex.RLock()

	argCopy := make([]*StorageInterfaceMockUpdateParams, len(mmUpdate.callArgs))
	copy(argCopy, mmUpdate.callArgs)

	mmUpdate.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateDone returns true if the count of the Update invocations corresponds
// the number of defined expectations
func (m *StorageInterfaceMock) MinimockUpdateDone() bool {
	if m.UpdateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateMock.invocationsDone()
}

// MinimockUpdateInspect logs each unmet expectation
func (m *StorageInterfaceMock) MinimockUpdateInspect() {
	for _, e := range m.UpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to StorageInterfaceMock.Update at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateCounter := mm_atomic.LoadUint64(&m.afterUpdateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateMock.defaultExpectation != nil && afterUpdateCounter < 1 {
		if m.UpdateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to StorageInterfaceMock.Update at\n%s", m.UpdateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to StorageInterfaceMock.Update at\n%s with params: %#v", m.UpdateMock.defaultExpectation.expectationOrigins.origin, *m.UpdateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdate != nil && afterUpdateCounter < 1 {
		m.t.Errorf("Expected call to StorageInterfaceMock.Update at\n%s", m.funcUpdateOrigin)
	}

	if !m.UpdateMock.invocationsDone() && afterUpdateCounter > 0 {
		m.t.Errorf("Expected %d calls to StorageInterfaceMock.Update at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateMock.expectedInvocations), m.UpdateMock.expectedInvocationsOrigin, afterUpdateCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *StorageInterfaceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockDeleteInspect()

			m.MinimockGetUserInspect()

			m.MinimockLogInspect()

			m.MinimockSaveInspect()

			m.MinimockUpdateInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *StorageInterfaceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *StorageInterfaceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockDeleteDone() &&
		m.MinimockGetUserDone() &&
		m.MinimockLogDone() &&
		m.MinimockSaveDone() &&
		m.MinimockUpdateDone()
}
